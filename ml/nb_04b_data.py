# AUTOGENERATED! DO NOT EDIT! File to edit: ../04b_dataset_more_abstract.ipynb.

# %% auto 0
__all__ = ['PatchedTransform']

# %% ../04b_dataset_more_abstract.ipynb 24
from .nb_03_dataset import *

# %% ../04b_dataset_more_abstract.ipynb 26
class PatchedTransform(Transform):

    """Returns a batch of N patches with the specified target in dataframe"""
    
    def __init__(self, 
                 img_path, # Path with images   
                 df, # pandas dataframe
                 y_col, # df column for target
                 stime_col, #df column with survival time
                 N, # number of patches
                 mean, #mean for normalization
                 std,  #std for normalization
                 trfms=None #list of transforms
                ):
        self.img_path = img_path
        self.df = df
        self.df.reset_index()
        self.y_col = y_col
        self.stime_col = stime_col
        self.N = N
        self.mean, self.std = mean, std
        self.trfms = trfms
        self.img_ids = self.get_img_ids()
        
    def get_img_ids(self):
        col = self.img_path.str()+"/"+self.df.TMA_ID+"_"+self.df.TMASpot
        return col.tolist()
                
        
    def encodes(self, idx):
        img_id = self.img_ids[idx]
        y = self.df.iloc[idx][self.y_col]
        patch_paths = [img_id+"_"+str(i)+".png" for i in range(self.N)]
        patches = []
        
        
        
        for p in patch_paths:
            #img = PILImage.create(p)
            img = open_patch(p)
            
            if self.trfms is not None: 
                trnfs = torch.nn.Sequential(*self.trfms)
                img = trnfs(img)

            patches.append(img)
            
        #patches = torch.stack(patches, dim=0)
        
        return PatchedImage(patches,torch.LongTensor([y]).squeeze())
    #(TensorImage(patches), torch.Tensor([y]).squeeze())
